#pragma once

#include <vector>
#include <deque>
#include <queue>
#include <unordered_set>
#include <unordered_map>
#include <set>
#include <map>

#include "skl_pool/hugepage_buffer_pool"

//! Convenience alias for hugepage-backed vector
template <typename _T>
using hugepage_vector = std::vector<_T, skl::hugepage_allocator<_T>>;

//! Convenience alias for hugepage-backed deque
template <typename _T>
using hugepage_deque = std::deque<_T, skl::hugepage_allocator<_T>>;

//! Convenience alias for hugepage-backed priority queue
template <typename _T, typename _Container = hugepage_vector<_T>, typename _Compare = std::less<typename _Container::value_type>>
using hugepage_priority_queue = std::priority_queue<_T, _Container, _Compare>;

//! Convenience alias for hugepage-backed queue
template <typename _T, typename _Container = hugepage_deque<_T>>
using hugepage_queue = std::queue<_T, _Container>;

//! Convenience alias for hugepage-backed unordered set
template <typename _Key, typename _Hash = std::hash<_Key>, typename _KeyEqual = std::equal_to<_Key>>
using hugepage_unordered_set = std::unordered_set<_Key, _Hash, _KeyEqual, skl::hugepage_allocator<_Key>>;

//! Convenience alias for hugepage-backed unordered map
template <typename _Key, typename _Value, typename _Hash = std::hash<_Key>, typename _KeyEqual = std::equal_to<_Key>>
using hugepage_unordered_map = std::unordered_map<_Key, _Value, _Hash, _KeyEqual, skl::hugepage_allocator<std::pair<const _Key, _Value>>>;

//! Convenience alias for hugepage-backed set
template <typename _Key, typename _Compare = std::less<_Key>>
using hugepage_set = std::set<_Key, _Compare, skl::hugepage_allocator<_Key>>;

//! Convenience alias for hugepage-backed map
template <typename _Key, typename _Value, typename _Compare = std::less<_Key>>
using hugepage_map = std::map<_Key, _Value, _Compare, skl::hugepage_allocator<std::pair<const _Key, _Value>>>;
