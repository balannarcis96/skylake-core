//!
//! \file skl_sguid
//!
//! \brief small guid
//!
//! \license Licensed under the MIT License. See LICENSE for details.
//!
#pragma once

#include "skl_buffer_view"

namespace skl {
//! Size of a SGUID in bytes
constexpr byte CSGUIDSize = 4u;

//! Raw small guid byte array
using SGUID_raw_t = byte[CSGUIDSize];

//! Raw small guid u32 type
using SGUID_u32_t = u32;

//! Simple, 4 random bytes small-guid
//! \remark Default constructs to the null-guid (4 zero bytes)
struct alignas(4u) SGUID {
    static constexpr byte CSize = CSGUIDSize;

    //! Default construct as null-guid
    constexpr SGUID() noexcept
        : m_data{0U, 0U, 0U, 0U} {
    }

    //! Construct from raw byte array
    constexpr SGUID(SGUID_raw_t f_raw) noexcept
        : m_data{f_raw[0U], f_raw[1U], f_raw[2U], f_raw[3U]} {
    }

    //! Construct with specific bytes
    constexpr SGUID(byte f_byte_1, byte f_byte_2, byte f_byte_3, byte f_byte_4) noexcept
        : m_data{f_byte_1, f_byte_2, f_byte_3, f_byte_4} {
    }

    //! Construct with specific u32 value
    constexpr SGUID(u32 f_value) noexcept
        : m_data{static_cast<byte>((f_value >> 24u) & 0xffu),
                 static_cast<byte>((f_value >> 16u) & 0xffu),
                 static_cast<byte>((f_value >> 8u) & 0xffu),
                 static_cast<byte>(f_value & 0xffu)} {
    }

    constexpr SGUID(const SGUID&) noexcept  = default;
    SGUID& operator=(const SGUID&) noexcept = default;
    SGUID(SGUID&&) noexcept                 = default;
    SGUID& operator=(SGUID&&) noexcept      = default;
    constexpr ~SGUID() noexcept             = default;

    [[nodiscard]] constexpr u32 raw() const noexcept {
        return __builtin_bit_cast(u32, m_data);
    }

    [[nodiscard]] constexpr bool operator==(const SGUID& f_other) const noexcept {
        return (u8(f_other.m_data[0u] == m_data[0u])
                & u8(f_other.m_data[1u] == m_data[1u])
                & u8(f_other.m_data[2u] == m_data[2u])
                & u8(f_other.m_data[3u] == m_data[3u]))
            != 0u;
    }

    [[nodiscard]] constexpr bool operator!=(const SGUID& f_other) const noexcept {
        return (u8(f_other.m_data[0u] == m_data[0u])
                & u8(f_other.m_data[1u] == m_data[1u])
                & u8(f_other.m_data[2u] == m_data[2u])
                & u8(f_other.m_data[3u] == m_data[3u]))
            == 0u;
    }

    [[nodiscard]] constexpr bool is_null() const noexcept {
        return (u8(m_data[0u] == 0u)
                & u8(m_data[1u] == 0u)
                & u8(m_data[2u] == 0u)
                & u8(m_data[3u] == 0u))
            != 0u;
    }

    void to_string(skl_buffer_view f_target_buffer) const noexcept;

    [[nodiscard]] constexpr byte operator[](u64 f_index) const noexcept {
        return m_data[f_index];
    }

private:
    SGUID_raw_t m_data; //!< The 4 bytes of the small-guid
};

//! [LibInit][ThreadLocal] Make new small-guid
[[nodiscard]] SGUID make_sguid() noexcept;

//! [LibInit][ThreadLocal] Make new small-guid
//! \remark Faster, less "collision-safe"
[[nodiscard]] SGUID make_sguid_fast() noexcept;

//! Make new small-guid
//! \remark Creates new instance of SklRand on each call
[[nodiscard]] SGUID g_make_sguid() noexcept;

//! Make new small-guid
//! \remark Creates new instance of SklRand on each call
//! \remark Faster, less "collision-safe"
[[nodiscard]] SGUID g_make_sguid_fast() noexcept;
} // namespace skl

namespace skl {
constexpr SGUID SGUID_Zero{};                                          //!< Null SGUID
constexpr SGUID SGUID_Max{u8(0xffu), u8(0xffu), u8(0xffu), u8(0xffu)}; //!< Max SGUID

struct sguid_hash {
    [[nodiscard]] static u64 operator()(const skl::SGUID& f_guid) noexcept {
        return static_cast<u64>(f_guid.raw());
    }
};
} // namespace skl
