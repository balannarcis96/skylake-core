//!
//! \file skl_sguid64
//!
//! \brief small guid 64
//!
//! \license Licensed under the MIT License. See LICENSE for details.
//!
#pragma once

#include "skl_buffer_view"
#include "skl_string_view"

namespace skl {
//! Size of a SGUID64 in bytes
constexpr byte CSGUID64Size = 8u;

//! Raw small guid 64 byte array
using SGUID64_raw_t = byte[CSGUID64Size];

//! Raw small guid u64 type
using SGUID64_u64_t = u64;

//! Simple, 8 random bytes small-guid
//! \remark Default constructs to the null-guid (8 zero bytes)
struct alignas(8u) SGUID64 {
    static constexpr byte CSize = CSGUID64Size;

    //! Default construct as null-guid
    constexpr SGUID64() noexcept
        : m_data{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U} {
    }

    //! Construct from raw byte array
    constexpr SGUID64(SGUID64_raw_t f_raw) noexcept
        : m_data{f_raw[0U], f_raw[1U], f_raw[2U], f_raw[3U], f_raw[4U], f_raw[5U], f_raw[6U], f_raw[7U]} {
    }

    //! Construct with specific bytes
    constexpr SGUID64(byte f_byte_1, byte f_byte_2, byte f_byte_3, byte f_byte_4, byte f_byte_5, byte f_byte_6, byte f_byte_7, byte f_byte_8) noexcept
        : m_data{f_byte_1, f_byte_2, f_byte_3, f_byte_4, f_byte_5, f_byte_6, f_byte_7, f_byte_8} {
    }

    //! Construct with specific u64 value
    constexpr SGUID64(u64 f_value) noexcept
        : m_data{static_cast<byte>(f_value & 0xffu),
                 static_cast<byte>((f_value >> 8u) & 0xffu),
                 static_cast<byte>((f_value >> 16u) & 0xffu),
                 static_cast<byte>((f_value >> 24u) & 0xffu),
                 static_cast<byte>((f_value >> 32u) & 0xffu),
                 static_cast<byte>((f_value >> 40u) & 0xffu),
                 static_cast<byte>((f_value >> 48u) & 0xffu),
                 static_cast<byte>((f_value >> 56u) & 0xffu)} {
    }

    constexpr SGUID64(const SGUID64&) noexcept  = default;
    SGUID64& operator=(const SGUID64&) noexcept = default;
    SGUID64(SGUID64&&) noexcept                 = default;
    SGUID64& operator=(SGUID64&&) noexcept      = default;
    constexpr ~SGUID64() noexcept               = default;

    [[nodiscard]] constexpr u64 raw() const noexcept {
        return __builtin_bit_cast(u64, m_data);
    }

    [[nodiscard]] constexpr bool operator==(const SGUID64& f_other) const noexcept {
        return (u8(f_other.m_data[0u] == m_data[0u])
                & u8(f_other.m_data[1u] == m_data[1u])
                & u8(f_other.m_data[2u] == m_data[2u])
                & u8(f_other.m_data[3u] == m_data[3u])
                & u8(f_other.m_data[4u] == m_data[4u])
                & u8(f_other.m_data[5u] == m_data[5u])
                & u8(f_other.m_data[6u] == m_data[6u])
                & u8(f_other.m_data[7u] == m_data[7u]))
            != 0u;
    }

    [[nodiscard]] constexpr bool operator!=(const SGUID64& f_other) const noexcept {
        return (u8(f_other.m_data[0u] == m_data[0u])
                & u8(f_other.m_data[1u] == m_data[1u])
                & u8(f_other.m_data[2u] == m_data[2u])
                & u8(f_other.m_data[3u] == m_data[3u])
                & u8(f_other.m_data[4u] == m_data[4u])
                & u8(f_other.m_data[5u] == m_data[5u])
                & u8(f_other.m_data[6u] == m_data[6u])
                & u8(f_other.m_data[7u] == m_data[7u]))
            == 0u;
    }

    [[nodiscard]] constexpr bool is_null() const noexcept {
        return (u8(m_data[0u] == 0u)
                & u8(m_data[1u] == 0u)
                & u8(m_data[2u] == 0u)
                & u8(m_data[3u] == 0u)
                & u8(m_data[4u] == 0u)
                & u8(m_data[5u] == 0u)
                & u8(m_data[6u] == 0u)
                & u8(m_data[7u] == 0u))
            != 0u;
    }

    //! Convert SGUID64 to hex string representation (16 characters)
    //! \param f_target_buffer Buffer to write the string into (must have space for at least 17 bytes including null terminator)
    //! \return Number of characters written (not including null terminator)
    //! \example "a1b2c3d4e5f6a7b8"
    [[nodiscard]] u64 to_string(skl_buffer_view f_target_buffer) const noexcept;

    //! Convert SGUID64 to hex string representation using thread-local buffer
    //! \return String view of the SGUID64 in hex format (16 characters)
    //! \warning Returns a view into thread-local storage - copy if persistence is needed
    [[nodiscard]] skl_string_view to_string() const noexcept;

    [[nodiscard]] constexpr byte operator[](u64 f_index) const noexcept {
        return m_data[f_index];
    }

private:
    SGUID64_raw_t m_data; //!< The 8 bytes of the small-guid
};

//! Copy SGUID64 raw bytes from input to output
//! \param in Source SGUID64 raw bytes
//! \param out Destination SGUID64 raw bytes
constexpr void copy_sguid64_raw(const SGUID64_raw_t in, SGUID64_raw_t out) noexcept {
    for (byte i = 0u; i < CSGUID64Size; ++i) {
        out[i] = in[i];
    }
}

//! [LibInit][ThreadLocal] Generate a new random SGUID64 (8 bytes)
//! \return A new SGUID64 with all 8 bytes randomized
//! \note Uses thread-local random number generator (requires LibInit)
//! \note High quality randomness, suitable for general use
//! \note 8-byte GUIDs offer better collision resistance than SGUID but less than full GUID
[[nodiscard]] SGUID64 make_sguid64() noexcept;

//! [LibInit][ThreadLocal] Generate a new random SGUID64 (fast)
//! \return A new SGUID64 with all 8 bytes randomized
//! \note Uses thread-local random number generator (requires LibInit)
//! \note Uses 2x u32 random calls instead of 8x byte-range calls
//! \note 8-byte GUIDs offer better collision resistance than SGUID but less than full GUID
[[nodiscard]] SGUID64 make_sguid64_fast() noexcept;

//! Generate a new random SGUID64 (global, non-thread-local)
//! \return A new SGUID64 with all 8 bytes randomized
//! \note Creates a new SklRand instance on each call (slower than make_sguid64)
//! \note Does not require thread-local initialization
//! \note 8-byte GUIDs offer better collision resistance than SGUID but less than full GUID
[[nodiscard]] SGUID64 g_make_sguid64() noexcept;

//! Generate a new random SGUID64 (global, non-thread-local, fast)
//! \return A new SGUID64 with all 8 bytes randomized
//! \note Creates a new SklRand instance on each call (slower than make_sguid64_fast)
//! \note Does not require thread-local initialization
//! \note 8-byte GUIDs offer better collision resistance than SGUID but less than full GUID
[[nodiscard]] SGUID64 g_make_sguid64_fast() noexcept;
} // namespace skl

namespace skl {
constexpr SGUID64 SGUID64_Zero{};                                                                                      //!< Null SGUID64
constexpr SGUID64 SGUID64_Max{u8(0xffu), u8(0xffu), u8(0xffu), u8(0xffu), u8(0xffu), u8(0xffu), u8(0xffu), u8(0xffu)}; //!< Max SGUID64

struct sguid64_hash {
    [[nodiscard]] static u64 operator()(const skl::SGUID64& f_guid) noexcept {
        return f_guid.raw();
    }
};
} // namespace skl
