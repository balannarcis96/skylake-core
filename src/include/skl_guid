//!
//! \file skl_guid
//!
//! \license Licensed under the MIT License. See LICENSE for details.
//!
#pragma once

#include "skl_string_view"
#include "skl_buffer_view"
#include "skl_pair"

namespace skl {
//! Size of a GUID in bytes
constexpr byte CGUIDSize = 16u;

//! Raw guid byte array
using GUID_raw_t = byte[CGUIDSize];

//! Raw guid byte array
using GUID_u64_t = u64[2u];

//! Simple, 16 random bytes guid
//! \remark Default constructs to the null-guid (16 zero bytes)
struct alignas(8u) GUID {
    static constexpr byte CSize = CGUIDSize;

    //Default construct as null-guid
    constexpr GUID() noexcept = default;

    //! Construct from low and high u64 parts
    constexpr GUID(u64 f_low, u64 f_high) noexcept
        : m_low{f_low}
        , m_high{f_high} {
    }

    //! Construct from raw byte array
    constexpr GUID(const GUID_raw_t f_raw) noexcept
        : m_low{static_cast<u64>(f_raw[0])
                | static_cast<u64>(f_raw[1]) << 8u
                | static_cast<u64>(f_raw[2]) << 16u
                | static_cast<u64>(f_raw[3]) << 24u
                | static_cast<u64>(f_raw[4]) << 32u
                | static_cast<u64>(f_raw[5]) << 40u
                | static_cast<u64>(f_raw[6]) << 48u
                | static_cast<u64>(f_raw[7]) << 56u}
        , m_high{static_cast<u64>(f_raw[8])
                 | static_cast<u64>(f_raw[9]) << 8u
                 | static_cast<u64>(f_raw[10]) << 16u
                 | static_cast<u64>(f_raw[11]) << 24u
                 | static_cast<u64>(f_raw[12]) << 32u
                 | static_cast<u64>(f_raw[13]) << 40u
                 | static_cast<u64>(f_raw[14]) << 48u
                 | static_cast<u64>(f_raw[15]) << 56u} {
    }

    //! Construct with specific bytes
    constexpr GUID(byte f_b0,
                   byte f_b1,
                   byte f_b2,
                   byte f_b3,
                   byte f_b4,
                   byte f_b5,
                   byte f_b6,
                   byte f_b7,
                   byte f_b8,
                   byte f_b9,
                   byte f_b10,
                   byte f_b11,
                   byte f_b12,
                   byte f_b13,
                   byte f_b14,
                   byte f_b15) noexcept
        : m_low{static_cast<u64>(f_b0)
                | static_cast<u64>(f_b1) << 8u
                | static_cast<u64>(f_b2) << 16u
                | static_cast<u64>(f_b3) << 24u
                | static_cast<u64>(f_b4) << 32u
                | static_cast<u64>(f_b5) << 40u
                | static_cast<u64>(f_b6) << 48u
                | static_cast<u64>(f_b7) << 56u}
        , m_high{static_cast<u64>(f_b8)
                 | static_cast<u64>(f_b9) << 8u
                 | static_cast<u64>(f_b10) << 16u
                 | static_cast<u64>(f_b11) << 24u
                 | static_cast<u64>(f_b12) << 32u
                 | static_cast<u64>(f_b13) << 40u
                 | static_cast<u64>(f_b14) << 48u
                 | static_cast<u64>(f_b15) << 56u} {
    }

    constexpr GUID(const GUID&) noexcept            = default;
    constexpr GUID& operator=(const GUID&) noexcept = default;
    constexpr GUID(GUID&&) noexcept                 = default;
    constexpr GUID& operator=(GUID&&) noexcept      = default;
    constexpr ~GUID() noexcept                      = default;

    [[nodiscard]] constexpr pair<u64, u64> raw() const noexcept {
        return {m_low, m_high};
    }

    //! Extract raw bytes into provided byte array
    //! \param out Destination byte array to fill with GUID bytes
    constexpr void raw(GUID_raw_t& out) const noexcept {
        out[0]  = static_cast<byte>(m_low & 0xffu);
        out[1]  = static_cast<byte>((m_low >> 8u) & 0xffu);
        out[2]  = static_cast<byte>((m_low >> 16u) & 0xffu);
        out[3]  = static_cast<byte>((m_low >> 24u) & 0xffu);
        out[4]  = static_cast<byte>((m_low >> 32u) & 0xffu);
        out[5]  = static_cast<byte>((m_low >> 40u) & 0xffu);
        out[6]  = static_cast<byte>((m_low >> 48u) & 0xffu);
        out[7]  = static_cast<byte>((m_low >> 56u) & 0xffu);
        out[8]  = static_cast<byte>(m_high & 0xffu);
        out[9]  = static_cast<byte>((m_high >> 8u) & 0xffu);
        out[10] = static_cast<byte>((m_high >> 16u) & 0xffu);
        out[11] = static_cast<byte>((m_high >> 24u) & 0xffu);
        out[12] = static_cast<byte>((m_high >> 32u) & 0xffu);
        out[13] = static_cast<byte>((m_high >> 40u) & 0xffu);
        out[14] = static_cast<byte>((m_high >> 48u) & 0xffu);
        out[15] = static_cast<byte>((m_high >> 56u) & 0xffu);
    }

    [[nodiscard]] constexpr bool operator==(const GUID& f_other) const noexcept {
        return m_low == f_other.m_low && m_high == f_other.m_high;
    }

    [[nodiscard]] constexpr bool is_null() const noexcept {
        return (m_low | m_high) == 0u;
    }

    //! Convert GUID to hex string representation (32 characters, no dashes)
    //! \param f_target_buffer Buffer to write the string into (must have space for at least 33 bytes including null terminator)
    //! \return Number of characters written (not including null terminator)
    //! \example "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6"
    [[nodiscard]] u64 to_string(skl_buffer_view f_target_buffer) const noexcept;

    //! Convert GUID to hex string representation using thread-local buffer
    //! \return String view of the GUID in hex format (32 characters, no dashes)
    //! \warning Returns a view into thread-local storage - copy if persistence is needed
    [[nodiscard]] skl_string_view to_string() const noexcept;

    //! Convert GUID to fancy hex string representation with dashes (36 characters)
    //! \param f_target_buffer Buffer to write the string into (must have space for at least 37 bytes including null terminator)
    //! \return Number of characters written (not including null terminator)
    //! \example "a1b2c3d4-e5f6-a7b8-c9d0-e1f2a3b4c5d6"
    [[nodiscard]] u64 to_string_fancy(skl_buffer_view f_target_buffer) const noexcept;

    //! Convert GUID to fancy hex string representation with dashes using thread-local buffer
    //! \return String view of the GUID in fancy hex format (36 characters with dashes)
    //! \warning Returns a view into thread-local storage - copy if persistence is needed
    //! \example "a1b2c3d4-e5f6-a7b8-c9d0-e1f2a3b4c5d6"
    [[nodiscard]] skl_string_view to_string_fancy() const noexcept;

private:
    u64 m_low{0u};
    u64 m_high{0u};
};

//! Copy GUID raw bytes from input to output
//! \param in Source GUID raw bytes
//! \param out Destination GUID raw bytes
constexpr void copy_guid_raw(const GUID_raw_t in, GUID_raw_t out) noexcept {
    for (byte i = 0u; i < CGUIDSize; ++i) {
        out[i] = in[i];
    }
}

//! [LibInit][ThreadLocal] Generate a new random GUID
//! \return A new GUID with all 16 bytes randomized
//! \note Uses thread-local random number generator (requires LibInit)
//! \note High quality randomness, suitable for general use
[[nodiscard]] GUID make_guid() noexcept;

//! [LibInit][ThreadLocal] Generate a new random GUID (fast)
//! \return A new GUID with all 16 bytes randomized
//! \note Uses thread-local random number generator (requires LibInit)
//! \note Faster than make_guid() but with slightly higher collision probability
//! \note Uses 4x u32 random calls instead of 16x byte-range calls
[[nodiscard]] GUID make_guid_fast() noexcept;

//! Generate a new random GUID (global, non-thread-local)
//! \return A new GUID with all 16 bytes randomized
//! \note Creates a new SklRand instance on each call (slower than make_guid)
//! \note Does not require thread-local initialization
//! \note High quality randomness, suitable for general use
[[nodiscard]] GUID g_make_guid() noexcept;

//! Generate a new random GUID (global, non-thread-local, fast)
//! \return A new GUID with all 16 bytes randomized
//! \note Creates a new SklRand instance on each call (slower than make_guid_fast)
//! \note Does not require thread-local initialization
//! \note Faster than g_make_guid() but with slightly higher collision probability
[[nodiscard]] GUID g_make_guid_fast() noexcept;
} // namespace skl

namespace skl {
//! Null GUID
constexpr GUID GUID_Zero{};

//! Max GUID
constexpr GUID GUID_Max{0xffffffffffffffffull, 0xffffffffffffffffull};

struct guid_hash {
    [[nodiscard]] static u64 operator()(const skl::GUID& f_guid) noexcept {
        const auto [lo, hi] = f_guid.raw();
        return lo ^ hi;
    }
};
} // namespace skl
